{"ast":null,"code":"\"use strict\";\n\nimport { getDefaultHeaderHeight, SafeAreaProviderCompat } from '@react-navigation/elements';\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { forModalPresentationIOS, forNoAnimation as forNoAnimationCard } from \"../../TransitionConfigs/CardStyleInterpolators.js\";\nimport { BottomSheetAndroid, DefaultTransition, FadeFromBottomAndroid, FadeFromRightAndroid, ModalFadeTransition, ModalSlideFromBottomIOS, ModalTransition, RevealFromBottomAndroid, ScaleFromCenterAndroid, SlideFromLeftIOS, SlideFromRightIOS } from \"../../TransitionConfigs/TransitionPresets.js\";\nimport { findLastIndex } from \"../../utils/findLastIndex.js\";\nimport { getDistanceForDirection } from \"../../utils/getDistanceForDirection.js\";\nimport { getModalRouteKeys } from \"../../utils/getModalRoutesKeys.js\";\nimport { MaybeScreen, MaybeScreenContainer } from \"../Screens.js\";\nimport { CardContainer } from \"./CardContainer.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst NAMED_TRANSITIONS_PRESETS = {\n  default: DefaultTransition,\n  fade: ModalFadeTransition,\n  fade_from_bottom: FadeFromBottomAndroid,\n  fade_from_right: FadeFromRightAndroid,\n  none: DefaultTransition,\n  reveal_from_bottom: RevealFromBottomAndroid,\n  scale_from_center: ScaleFromCenterAndroid,\n  slide_from_left: SlideFromLeftIOS,\n  slide_from_right: SlideFromRightIOS,\n  slide_from_bottom: Platform.select({\n    ios: ModalSlideFromBottomIOS,\n    default: BottomSheetAndroid\n  })\n};\nconst EPSILON = 1e-5;\nconst STATE_INACTIVE = 0;\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nconst STATE_ON_TOP = 2;\nconst FALLBACK_DESCRIPTOR = Object.freeze({\n  options: {}\n});\nconst getInterpolationIndex = (scenes, index) => {\n  const {\n    cardStyleInterpolator\n  } = scenes[index].descriptor.options;\n  let interpolationIndex = 0;\n  for (let i = index - 1; i >= 0; i--) {\n    const cardStyleInterpolatorCurrent = scenes[i]?.descriptor.options.cardStyleInterpolator;\n    if (cardStyleInterpolatorCurrent !== cardStyleInterpolator) {\n      break;\n    }\n    interpolationIndex++;\n  }\n  return interpolationIndex;\n};\nconst getIsModalPresentation = cardStyleInterpolator => {\n  return cardStyleInterpolator === forModalPresentationIOS || cardStyleInterpolator.name === 'forModalPresentationIOS';\n};\nconst getIsModal = (scene, interpolationIndex, isParentModal) => {\n  if (isParentModal) {\n    return true;\n  }\n  const {\n    cardStyleInterpolator\n  } = scene.descriptor.options;\n  const isModalPresentation = getIsModalPresentation(cardStyleInterpolator);\n  const isModal = isModalPresentation && interpolationIndex !== 0;\n  return isModal;\n};\nconst getHeaderHeights = (scenes, insets, isParentHeaderShown, isParentModal, layout, previous) => {\n  return scenes.reduce((acc, curr, index) => {\n    const {\n      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,\n      headerStyle\n    } = curr.descriptor.options;\n    const style = StyleSheet.flatten(headerStyle || {});\n    const height = 'height' in style && typeof style.height === 'number' ? style.height : previous[curr.route.key];\n    const interpolationIndex = getInterpolationIndex(scenes, index);\n    const isModal = getIsModal(curr, interpolationIndex, isParentModal);\n    acc[curr.route.key] = typeof height === 'number' ? height : getDefaultHeaderHeight(layout, isModal, headerStatusBarHeight);\n    return acc;\n  }, {});\n};\nconst getDistanceFromOptions = (layout, options, isRTL) => {\n  if (options?.gestureDirection) {\n    return getDistanceForDirection(layout, options.gestureDirection, isRTL);\n  }\n  const defaultGestureDirection = options?.presentation === 'modal' ? ModalTransition.gestureDirection : DefaultTransition.gestureDirection;\n  const gestureDirection = options?.animation ? NAMED_TRANSITIONS_PRESETS[options?.animation]?.gestureDirection : defaultGestureDirection;\n  return getDistanceForDirection(layout, gestureDirection, isRTL);\n};\nconst getProgressFromGesture = (gesture, layout, options, isRTL) => {\n  const distance = getDistanceFromOptions({\n    width: Math.max(1, layout.width),\n    height: Math.max(1, layout.height)\n  }, options, isRTL);\n  if (distance > 0) {\n    return gesture.interpolate({\n      inputRange: [0, distance],\n      outputRange: [1, 0]\n    });\n  }\n  return gesture.interpolate({\n    inputRange: [distance, 0],\n    outputRange: [0, 1]\n  });\n};\nfunction getDefaultAnimation(animation) {\n  const excludedPlatforms = Platform.OS !== 'web' && Platform.OS !== 'windows' && Platform.OS !== 'macos';\n  return animation ?? (excludedPlatforms ? 'default' : 'none');\n}\nexport function getAnimationEnabled(animation) {\n  return getDefaultAnimation(animation) !== 'none';\n}\nexport class CardStack extends React.Component {\n  static getDerivedStateFromProps(props, state) {\n    if (props.routes === state.routes && props.descriptors === state.descriptors) {\n      return null;\n    }\n    const gestures = [...props.routes, ...props.state.preloadedRoutes].reduce((acc, curr) => {\n      const descriptor = props.descriptors[curr.key] || props.preloadedDescriptors[curr.key];\n      const {\n        animation\n      } = descriptor?.options || {};\n      acc[curr.key] = state.gestures[curr.key] || new Animated.Value(props.openingRouteKeys.includes(curr.key) && getAnimationEnabled(animation) || props.state.preloadedRoutes.includes(curr) ? getDistanceFromOptions(state.layout, descriptor?.options, props.direction === 'rtl') : 0);\n      return acc;\n    }, {});\n    const modalRouteKeys = getModalRouteKeys([...props.routes, ...props.state.preloadedRoutes], Object.assign({}, props.descriptors, props.preloadedDescriptors));\n    const scenes = [...props.routes, ...props.state.preloadedRoutes].map((route, index, self) => {\n      const isPreloaded = props.state.preloadedRoutes.includes(route);\n      const previousRoute = isPreloaded ? undefined : self[index - 1];\n      const nextRoute = isPreloaded ? undefined : self[index + 1];\n      const oldScene = state.scenes[index];\n      const currentGesture = gestures[route.key];\n      const previousGesture = previousRoute ? gestures[previousRoute.key] : undefined;\n      const nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;\n      const descriptor = (isPreloaded ? props.preloadedDescriptors : props.descriptors)[route.key] || state.descriptors[route.key] || (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);\n      const nextOptions = nextRoute && (props.descriptors[nextRoute?.key] || state.descriptors[nextRoute?.key])?.options;\n      const previousOptions = previousRoute && (props.descriptors[previousRoute?.key] || state.descriptors[previousRoute?.key])?.options;\n      const optionsForTransitionConfig = index !== self.length - 1 && nextOptions && nextOptions?.presentation !== 'transparentModal' ? nextOptions : descriptor.options;\n      const isModal = modalRouteKeys.includes(route.key);\n      const animation = getDefaultAnimation(optionsForTransitionConfig.animation);\n      const isAnimationEnabled = getAnimationEnabled(animation);\n      const transitionPreset = animation !== 'default' ? NAMED_TRANSITIONS_PRESETS[animation] : isModal || optionsForTransitionConfig.presentation === 'modal' ? ModalTransition : optionsForTransitionConfig.presentation === 'transparentModal' ? ModalFadeTransition : DefaultTransition;\n      const {\n        gestureEnabled = Platform.OS === 'ios' && isAnimationEnabled,\n        gestureDirection = transitionPreset.gestureDirection,\n        transitionSpec = transitionPreset.transitionSpec,\n        cardStyleInterpolator = isAnimationEnabled ? transitionPreset.cardStyleInterpolator : forNoAnimationCard,\n        headerStyleInterpolator = transitionPreset.headerStyleInterpolator,\n        cardOverlayEnabled = Platform.OS !== 'ios' && optionsForTransitionConfig.presentation !== 'transparentModal' || getIsModalPresentation(cardStyleInterpolator)\n      } = optionsForTransitionConfig;\n      const headerMode = descriptor.options.headerMode ?? (!(optionsForTransitionConfig.presentation === 'modal' || optionsForTransitionConfig.presentation === 'transparentModal' || nextOptions?.presentation === 'modal' || nextOptions?.presentation === 'transparentModal' || getIsModalPresentation(cardStyleInterpolator)) && Platform.OS === 'ios' && descriptor.options.header === undefined ? 'float' : 'screen');\n      const isRTL = props.direction === 'rtl';\n      const scene = {\n        route,\n        descriptor: Object.assign({}, descriptor, {\n          options: Object.assign({}, descriptor.options, {\n            animation,\n            cardOverlayEnabled,\n            cardStyleInterpolator,\n            gestureDirection,\n            gestureEnabled,\n            headerStyleInterpolator,\n            transitionSpec,\n            headerMode\n          })\n        }),\n        progress: {\n          current: getProgressFromGesture(currentGesture, state.layout, descriptor.options, isRTL),\n          next: nextGesture && nextOptions?.presentation !== 'transparentModal' ? getProgressFromGesture(nextGesture, state.layout, nextOptions, isRTL) : undefined,\n          previous: previousGesture ? getProgressFromGesture(previousGesture, state.layout, previousOptions, isRTL) : undefined\n        },\n        __memo: [state.layout, descriptor, nextOptions, previousOptions, currentGesture, nextGesture, previousGesture]\n      };\n      if (oldScene && scene.__memo.every((it, i) => {\n        return oldScene.__memo[i] === it;\n      })) {\n        return oldScene;\n      }\n      return scene;\n    });\n    return {\n      routes: props.routes,\n      scenes,\n      gestures,\n      descriptors: props.descriptors,\n      headerHeights: getHeaderHeights(scenes, props.insets, props.isParentHeaderShown, props.isParentModal, state.layout, state.headerHeights)\n    };\n  }\n  constructor(props) {\n    super(props);\n    this.state = {\n      routes: [],\n      scenes: [],\n      gestures: {},\n      layout: SafeAreaProviderCompat.initialMetrics.frame,\n      descriptors: this.props.descriptors,\n      headerHeights: {}\n    };\n  }\n  handleLayout = e => {\n    const {\n      height,\n      width\n    } = e.nativeEvent.layout;\n    const layout = {\n      width,\n      height\n    };\n    this.setState((state, props) => {\n      if (height === state.layout.height && width === state.layout.width) {\n        return null;\n      }\n      return {\n        layout,\n        headerHeights: getHeaderHeights(state.scenes, props.insets, props.isParentHeaderShown, props.isParentModal, layout, state.headerHeights)\n      };\n    });\n  };\n  handleHeaderLayout = ({\n    route,\n    height\n  }) => {\n    this.setState(({\n      headerHeights\n    }) => {\n      const previousHeight = headerHeights[route.key];\n      if (previousHeight === height) {\n        return null;\n      }\n      return {\n        headerHeights: Object.assign({}, headerHeights, {\n          [route.key]: height\n        })\n      };\n    });\n  };\n  getFocusedRoute = () => {\n    const {\n      state\n    } = this.props;\n    return state.routes[state.index];\n  };\n  getPreviousScene = ({\n    route\n  }) => {\n    const {\n      getPreviousRoute\n    } = this.props;\n    const {\n      scenes\n    } = this.state;\n    const previousRoute = getPreviousRoute({\n      route\n    });\n    if (previousRoute) {\n      const previousScene = scenes.find(scene => scene.descriptor.route.key === previousRoute.key);\n      return previousScene;\n    }\n    return undefined;\n  };\n  render() {\n    const {\n      insets,\n      state,\n      routes,\n      openingRouteKeys,\n      closingRouteKeys,\n      onOpenRoute,\n      onCloseRoute,\n      renderHeader,\n      isParentHeaderShown,\n      isParentModal,\n      onTransitionStart,\n      onTransitionEnd,\n      onGestureStart,\n      onGestureEnd,\n      onGestureCancel,\n      detachInactiveScreens = Platform.OS === 'web' || Platform.OS === 'android' || Platform.OS === 'ios'\n    } = this.props;\n    const {\n      scenes,\n      layout,\n      gestures,\n      headerHeights\n    } = this.state;\n    const focusedRoute = state.routes[state.index];\n    const focusedHeaderHeight = headerHeights[focusedRoute.key];\n    const isFloatHeaderAbsolute = this.state.scenes.slice(-2).some(scene => {\n      const options = scene.descriptor.options ?? {};\n      const {\n        headerMode,\n        headerTransparent,\n        headerShown = true\n      } = options;\n      if (headerTransparent || headerShown === false || headerMode === 'screen') {\n        return true;\n      }\n      return false;\n    });\n    let activeScreensLimit = 1;\n    for (let i = scenes.length - 1; i >= 0; i--) {\n      const {\n        options\n      } = scenes[i].descriptor;\n      const {\n        detachPreviousScreen = options.presentation === 'transparentModal' ? false : getIsModalPresentation(options.cardStyleInterpolator) ? i !== findLastIndex(scenes, scene => {\n          const {\n            cardStyleInterpolator\n          } = scene.descriptor.options;\n          return cardStyleInterpolator === forModalPresentationIOS || cardStyleInterpolator?.name === 'forModalPresentationIOS';\n        }) : true\n      } = options;\n      if (detachPreviousScreen === false) {\n        activeScreensLimit++;\n      } else {\n        if (i <= scenes.length - 2) {\n          break;\n        }\n      }\n    }\n    const floatingHeader = _jsx(React.Fragment, {\n      children: renderHeader({\n        mode: 'float',\n        layout,\n        scenes,\n        getPreviousScene: this.getPreviousScene,\n        getFocusedRoute: this.getFocusedRoute,\n        onContentHeightChange: this.handleHeaderLayout,\n        style: [styles.floating, isFloatHeaderAbsolute && [{\n          height: focusedHeaderHeight\n        }, styles.absolute]]\n      })\n    }, \"header\");\n    return _jsxs(View, {\n      style: styles.container,\n      children: [isFloatHeaderAbsolute ? null : floatingHeader, _jsx(MaybeScreenContainer, {\n        enabled: detachInactiveScreens,\n        style: styles.container,\n        onLayout: this.handleLayout,\n        children: [...routes, ...state.preloadedRoutes].map((route, index) => {\n          const focused = focusedRoute.key === route.key;\n          const gesture = gestures[route.key];\n          const scene = scenes[index];\n          const isPreloaded = state.preloadedRoutes.includes(route) && !routes.includes(route);\n          if (state.preloadedRoutes.includes(route) && routes.includes(route) && index >= routes.length) {\n            return null;\n          }\n          let isScreenActive = 1;\n          if (index < routes.length - activeScreensLimit - 1 || isPreloaded) {\n            isScreenActive = STATE_INACTIVE;\n          } else {\n            const sceneForActivity = scenes[routes.length - 1];\n            const outputValue = index === routes.length - 1 ? STATE_ON_TOP : index >= routes.length - activeScreensLimit ? STATE_TRANSITIONING_OR_BELOW_TOP : STATE_INACTIVE;\n            isScreenActive = sceneForActivity ? sceneForActivity.progress.current.interpolate({\n              inputRange: [0, 1 - EPSILON, 1],\n              outputRange: [1, 1, outputValue],\n              extrapolate: 'clamp'\n            }) : STATE_TRANSITIONING_OR_BELOW_TOP;\n          }\n          const {\n            headerShown = true,\n            headerTransparent,\n            freezeOnBlur,\n            autoHideHomeIndicator\n          } = scene.descriptor.options;\n          const safeAreaInsetTop = insets.top;\n          const safeAreaInsetRight = insets.right;\n          const safeAreaInsetBottom = insets.bottom;\n          const safeAreaInsetLeft = insets.left;\n          const headerHeight = headerShown !== false ? headerHeights[route.key] : 0;\n          const interpolationIndex = getInterpolationIndex(scenes, index);\n          const isModal = getIsModal(scene, interpolationIndex, isParentModal);\n          const isNextScreenTransparent = scenes[index + 1]?.descriptor.options.presentation === 'transparentModal';\n          const detachCurrentScreen = scenes[index + 1]?.descriptor.options.detachPreviousScreen !== false;\n          return _jsx(MaybeScreen, {\n            style: [StyleSheet.absoluteFill],\n            enabled: detachInactiveScreens,\n            active: isScreenActive,\n            freezeOnBlur: freezeOnBlur,\n            shouldFreeze: isScreenActive === STATE_INACTIVE && !isPreloaded,\n            homeIndicatorHidden: autoHideHomeIndicator,\n            pointerEvents: \"box-none\",\n            children: _jsx(CardContainer, {\n              index: index,\n              interpolationIndex: interpolationIndex,\n              modal: isModal,\n              active: index === routes.length - 1,\n              focused: focused,\n              opening: openingRouteKeys.includes(route.key),\n              closing: closingRouteKeys.includes(route.key),\n              layout: layout,\n              gesture: gesture,\n              scene: scene,\n              safeAreaInsetTop: safeAreaInsetTop,\n              safeAreaInsetRight: safeAreaInsetRight,\n              safeAreaInsetBottom: safeAreaInsetBottom,\n              safeAreaInsetLeft: safeAreaInsetLeft,\n              onGestureStart: onGestureStart,\n              onGestureCancel: onGestureCancel,\n              onGestureEnd: onGestureEnd,\n              headerHeight: headerHeight,\n              isParentHeaderShown: isParentHeaderShown,\n              onHeaderHeightChange: this.handleHeaderLayout,\n              getPreviousScene: this.getPreviousScene,\n              getFocusedRoute: this.getFocusedRoute,\n              hasAbsoluteFloatHeader: isFloatHeaderAbsolute && !headerTransparent,\n              renderHeader: renderHeader,\n              onOpenRoute: onOpenRoute,\n              onCloseRoute: onCloseRoute,\n              onTransitionStart: onTransitionStart,\n              onTransitionEnd: onTransitionEnd,\n              isNextScreenTransparent: isNextScreenTransparent,\n              detachCurrentScreen: detachCurrentScreen,\n              preloaded: isPreloaded\n            })\n          }, route.key);\n        })\n      }), isFloatHeaderAbsolute ? floatingHeader : null]\n    });\n  }\n}\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  absolute: {\n    position: 'absolute',\n    top: 0,\n    start: 0,\n    end: 0\n  },\n  floating: {\n    zIndex: 1\n  }\n});","map":{"version":3,"names":["getDefaultHeaderHeight","SafeAreaProviderCompat","React","Animated","Platform","StyleSheet","View","forModalPresentationIOS","forNoAnimation","forNoAnimationCard","BottomSheetAndroid","DefaultTransition","FadeFromBottomAndroid","FadeFromRightAndroid","ModalFadeTransition","ModalSlideFromBottomIOS","ModalTransition","RevealFromBottomAndroid","ScaleFromCenterAndroid","SlideFromLeftIOS","SlideFromRightIOS","findLastIndex","getDistanceForDirection","getModalRouteKeys","MaybeScreen","MaybeScreenContainer","CardContainer","jsx","_jsx","jsxs","_jsxs","NAMED_TRANSITIONS_PRESETS","default","fade","fade_from_bottom","fade_from_right","none","reveal_from_bottom","scale_from_center","slide_from_left","slide_from_right","slide_from_bottom","select","ios","EPSILON","STATE_INACTIVE","STATE_TRANSITIONING_OR_BELOW_TOP","STATE_ON_TOP","FALLBACK_DESCRIPTOR","Object","freeze","options","getInterpolationIndex","scenes","index","cardStyleInterpolator","descriptor","interpolationIndex","i","cardStyleInterpolatorCurrent","getIsModalPresentation","name","getIsModal","scene","isParentModal","isModalPresentation","isModal","getHeaderHeights","insets","isParentHeaderShown","layout","previous","reduce","acc","curr","headerStatusBarHeight","top","headerStyle","style","flatten","height","route","key","getDistanceFromOptions","isRTL","gestureDirection","defaultGestureDirection","presentation","animation","getProgressFromGesture","gesture","distance","width","Math","max","interpolate","inputRange","outputRange","getDefaultAnimation","excludedPlatforms","OS","getAnimationEnabled","CardStack","Component","getDerivedStateFromProps","props","state","routes","descriptors","gestures","preloadedRoutes","preloadedDescriptors","Value","openingRouteKeys","includes","direction","modalRouteKeys","assign","map","self","isPreloaded","previousRoute","undefined","nextRoute","oldScene","currentGesture","previousGesture","nextGesture","nextOptions","previousOptions","optionsForTransitionConfig","length","isAnimationEnabled","transitionPreset","gestureEnabled","transitionSpec","headerStyleInterpolator","cardOverlayEnabled","headerMode","header","progress","current","next","__memo","every","it","headerHeights","constructor","initialMetrics","frame","handleLayout","e","nativeEvent","setState","handleHeaderLayout","previousHeight","getFocusedRoute","getPreviousScene","getPreviousRoute","previousScene","find","render","closingRouteKeys","onOpenRoute","onCloseRoute","renderHeader","onTransitionStart","onTransitionEnd","onGestureStart","onGestureEnd","onGestureCancel","detachInactiveScreens","focusedRoute","focusedHeaderHeight","isFloatHeaderAbsolute","slice","some","headerTransparent","headerShown","activeScreensLimit","detachPreviousScreen","floatingHeader","Fragment","children","mode","onContentHeightChange","styles","floating","absolute","container","enabled","onLayout","focused","isScreenActive","sceneForActivity","outputValue","extrapolate","freezeOnBlur","autoHideHomeIndicator","safeAreaInsetTop","safeAreaInsetRight","right","safeAreaInsetBottom","bottom","safeAreaInsetLeft","left","headerHeight","isNextScreenTransparent","detachCurrentScreen","absoluteFill","active","shouldFreeze","homeIndicatorHidden","pointerEvents","modal","opening","closing","onHeaderHeightChange","hasAbsoluteFloatHeader","preloaded","create","flex","position","start","end","zIndex"],"sources":["/home/runner/workspace/node_modules/@react-navigation/stack/src/views/Stack/CardStack.tsx"],"sourcesContent":["import {\n  getDefaultHeaderHeight,\n  SafeAreaProviderCompat,\n} from '@react-navigation/elements';\nimport type {\n  LocaleDirection,\n  ParamListBase,\n  Route,\n  StackNavigationState,\n} from '@react-navigation/native';\nimport * as React from 'react';\nimport {\n  Animated,\n  type LayoutChangeEvent,\n  Platform,\n  StyleSheet,\n  View,\n} from 'react-native';\nimport type { EdgeInsets } from 'react-native-safe-area-context';\n\nimport {\n  forModalPresentationIOS,\n  forNoAnimation as forNoAnimationCard,\n} from '../../TransitionConfigs/CardStyleInterpolators';\nimport {\n  BottomSheetAndroid,\n  DefaultTransition,\n  FadeFromBottomAndroid,\n  FadeFromRightAndroid,\n  ModalFadeTransition,\n  ModalSlideFromBottomIOS,\n  ModalTransition,\n  RevealFromBottomAndroid,\n  ScaleFromCenterAndroid,\n  SlideFromLeftIOS,\n  SlideFromRightIOS,\n} from '../../TransitionConfigs/TransitionPresets';\nimport type {\n  Layout,\n  Scene,\n  StackAnimationName,\n  StackCardStyleInterpolator,\n  StackDescriptorMap,\n  StackHeaderMode,\n  StackNavigationOptions,\n  TransitionPreset,\n} from '../../types';\nimport { findLastIndex } from '../../utils/findLastIndex';\nimport { getDistanceForDirection } from '../../utils/getDistanceForDirection';\nimport { getModalRouteKeys } from '../../utils/getModalRoutesKeys';\nimport type { Props as HeaderContainerProps } from '../Header/HeaderContainer';\nimport { MaybeScreen, MaybeScreenContainer } from '../Screens';\nimport { CardContainer } from './CardContainer';\n\ntype GestureValues = {\n  [key: string]: Animated.Value;\n};\n\ntype Props = {\n  direction: LocaleDirection;\n  insets: EdgeInsets;\n  state: StackNavigationState<ParamListBase>;\n  descriptors: StackDescriptorMap;\n  preloadedDescriptors: StackDescriptorMap;\n  routes: Route<string>[];\n  openingRouteKeys: string[];\n  closingRouteKeys: string[];\n  onOpenRoute: (props: { route: Route<string> }) => void;\n  onCloseRoute: (props: { route: Route<string> }) => void;\n  getPreviousRoute: (props: {\n    route: Route<string>;\n  }) => Route<string> | undefined;\n  renderHeader: (props: HeaderContainerProps) => React.ReactNode;\n  isParentHeaderShown: boolean;\n  isParentModal: boolean;\n  onTransitionStart: (\n    props: { route: Route<string> },\n    closing: boolean\n  ) => void;\n  onTransitionEnd: (props: { route: Route<string> }, closing: boolean) => void;\n  onGestureStart: (props: { route: Route<string> }) => void;\n  onGestureEnd: (props: { route: Route<string> }) => void;\n  onGestureCancel: (props: { route: Route<string> }) => void;\n  detachInactiveScreens?: boolean;\n};\n\ntype State = {\n  routes: Route<string>[];\n  descriptors: StackDescriptorMap;\n  scenes: Scene[];\n  gestures: GestureValues;\n  layout: Layout;\n  headerHeights: Record<string, number>;\n};\n\nconst NAMED_TRANSITIONS_PRESETS = {\n  default: DefaultTransition,\n  fade: ModalFadeTransition,\n  fade_from_bottom: FadeFromBottomAndroid,\n  fade_from_right: FadeFromRightAndroid,\n  none: DefaultTransition,\n  reveal_from_bottom: RevealFromBottomAndroid,\n  scale_from_center: ScaleFromCenterAndroid,\n  slide_from_left: SlideFromLeftIOS,\n  slide_from_right: SlideFromRightIOS,\n  slide_from_bottom: Platform.select({\n    ios: ModalSlideFromBottomIOS,\n    default: BottomSheetAndroid,\n  }),\n} as const satisfies Record<StackAnimationName, TransitionPreset>;\n\nconst EPSILON = 1e-5;\n\nconst STATE_INACTIVE = 0;\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nconst STATE_ON_TOP = 2;\n\nconst FALLBACK_DESCRIPTOR = Object.freeze({ options: {} });\n\nconst getInterpolationIndex = (scenes: Scene[], index: number) => {\n  const { cardStyleInterpolator } = scenes[index].descriptor.options;\n\n  // Start from current card and count backwards the number of cards with same interpolation\n  let interpolationIndex = 0;\n\n  for (let i = index - 1; i >= 0; i--) {\n    const cardStyleInterpolatorCurrent =\n      scenes[i]?.descriptor.options.cardStyleInterpolator;\n\n    if (cardStyleInterpolatorCurrent !== cardStyleInterpolator) {\n      break;\n    }\n\n    interpolationIndex++;\n  }\n\n  return interpolationIndex;\n};\n\nconst getIsModalPresentation = (\n  cardStyleInterpolator: StackCardStyleInterpolator\n) => {\n  return (\n    cardStyleInterpolator === forModalPresentationIOS ||\n    // Handle custom modal presentation interpolators as well\n    cardStyleInterpolator.name === 'forModalPresentationIOS'\n  );\n};\n\nconst getIsModal = (\n  scene: Scene,\n  interpolationIndex: number,\n  isParentModal: boolean\n) => {\n  if (isParentModal) {\n    return true;\n  }\n\n  const { cardStyleInterpolator } = scene.descriptor.options;\n  const isModalPresentation = getIsModalPresentation(cardStyleInterpolator);\n  const isModal = isModalPresentation && interpolationIndex !== 0;\n\n  return isModal;\n};\n\nconst getHeaderHeights = (\n  scenes: Scene[],\n  insets: EdgeInsets,\n  isParentHeaderShown: boolean,\n  isParentModal: boolean,\n  layout: Layout,\n  previous: Record<string, number>\n) => {\n  return scenes.reduce<Record<string, number>>((acc, curr, index) => {\n    const {\n      headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,\n      headerStyle,\n    } = curr.descriptor.options;\n\n    const style = StyleSheet.flatten(headerStyle || {});\n\n    const height =\n      'height' in style && typeof style.height === 'number'\n        ? style.height\n        : previous[curr.route.key];\n\n    const interpolationIndex = getInterpolationIndex(scenes, index);\n    const isModal = getIsModal(curr, interpolationIndex, isParentModal);\n\n    acc[curr.route.key] =\n      typeof height === 'number'\n        ? height\n        : getDefaultHeaderHeight(layout, isModal, headerStatusBarHeight);\n\n    return acc;\n  }, {});\n};\n\nconst getDistanceFromOptions = (\n  layout: Layout,\n  options: StackNavigationOptions | undefined,\n  isRTL: boolean\n) => {\n  if (options?.gestureDirection) {\n    return getDistanceForDirection(layout, options.gestureDirection, isRTL);\n  }\n\n  const defaultGestureDirection =\n    options?.presentation === 'modal'\n      ? ModalTransition.gestureDirection\n      : DefaultTransition.gestureDirection;\n\n  const gestureDirection = options?.animation\n    ? NAMED_TRANSITIONS_PRESETS[options?.animation]?.gestureDirection\n    : defaultGestureDirection;\n\n  return getDistanceForDirection(layout, gestureDirection, isRTL);\n};\n\nconst getProgressFromGesture = (\n  gesture: Animated.Value,\n  layout: Layout,\n  options: StackNavigationOptions | undefined,\n  isRTL: boolean\n) => {\n  const distance = getDistanceFromOptions(\n    {\n      // Make sure that we have a non-zero distance, otherwise there will be incorrect progress\n      // This causes blank screen on web if it was previously inside container with display: none\n      width: Math.max(1, layout.width),\n      height: Math.max(1, layout.height),\n    },\n    options,\n    isRTL\n  );\n\n  if (distance > 0) {\n    return gesture.interpolate({\n      inputRange: [0, distance],\n      outputRange: [1, 0],\n    });\n  }\n\n  return gesture.interpolate({\n    inputRange: [distance, 0],\n    outputRange: [0, 1],\n  });\n};\n\nfunction getDefaultAnimation(animation: StackAnimationName | undefined) {\n  // Disable screen transition animation by default on web, windows and macos to match the native behavior\n  const excludedPlatforms =\n    Platform.OS !== 'web' &&\n    Platform.OS !== 'windows' &&\n    Platform.OS !== 'macos';\n\n  return animation ?? (excludedPlatforms ? 'default' : 'none');\n}\n\nexport function getAnimationEnabled(animation: StackAnimationName | undefined) {\n  return getDefaultAnimation(animation) !== 'none';\n}\n\nexport class CardStack extends React.Component<Props, State> {\n  static getDerivedStateFromProps(\n    props: Props,\n    state: State\n  ): Partial<State> | null {\n    if (\n      props.routes === state.routes &&\n      props.descriptors === state.descriptors\n    ) {\n      return null;\n    }\n\n    const gestures = [\n      ...props.routes,\n      ...props.state.preloadedRoutes,\n    ].reduce<GestureValues>((acc, curr) => {\n      const descriptor =\n        props.descriptors[curr.key] || props.preloadedDescriptors[curr.key];\n      const { animation } = descriptor?.options || {};\n\n      acc[curr.key] =\n        state.gestures[curr.key] ||\n        new Animated.Value(\n          (props.openingRouteKeys.includes(curr.key) &&\n            getAnimationEnabled(animation)) ||\n          props.state.preloadedRoutes.includes(curr)\n            ? getDistanceFromOptions(\n                state.layout,\n                descriptor?.options,\n                props.direction === 'rtl'\n              )\n            : 0\n        );\n\n      return acc;\n    }, {});\n\n    const modalRouteKeys = getModalRouteKeys(\n      [...props.routes, ...props.state.preloadedRoutes],\n      {\n        ...props.descriptors,\n        ...props.preloadedDescriptors,\n      }\n    );\n\n    const scenes = [...props.routes, ...props.state.preloadedRoutes].map(\n      (route, index, self) => {\n        // For preloaded screens, we don't care about the previous and the next screen\n        const isPreloaded = props.state.preloadedRoutes.includes(route);\n        const previousRoute = isPreloaded ? undefined : self[index - 1];\n        const nextRoute = isPreloaded ? undefined : self[index + 1];\n\n        const oldScene = state.scenes[index];\n\n        const currentGesture = gestures[route.key];\n        const previousGesture = previousRoute\n          ? gestures[previousRoute.key]\n          : undefined;\n        const nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;\n\n        const descriptor =\n          (isPreloaded ? props.preloadedDescriptors : props.descriptors)[\n            route.key\n          ] ||\n          state.descriptors[route.key] ||\n          (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);\n\n        const nextOptions =\n          nextRoute &&\n          (\n            props.descriptors[nextRoute?.key] ||\n            state.descriptors[nextRoute?.key]\n          )?.options;\n\n        const previousOptions =\n          previousRoute &&\n          (\n            props.descriptors[previousRoute?.key] ||\n            state.descriptors[previousRoute?.key]\n          )?.options;\n\n        // When a screen is not the last, it should use next screen's transition config\n        // Many transitions also animate the previous screen, so using 2 different transitions doesn't look right\n        // For example combining a slide and a modal transition would look wrong otherwise\n        // With this approach, combining different transition styles in the same navigator mostly looks right\n        // This will still be broken when 2 transitions have different idle state (e.g. modal presentation),\n        // but the majority of the transitions look alright\n        const optionsForTransitionConfig =\n          index !== self.length - 1 &&\n          nextOptions &&\n          nextOptions?.presentation !== 'transparentModal'\n            ? nextOptions\n            : descriptor.options;\n\n        // Assume modal if there are already modal screens in the stack\n        // or current screen is a modal when no presentation is specified\n        const isModal = modalRouteKeys.includes(route.key);\n\n        const animation = getDefaultAnimation(\n          optionsForTransitionConfig.animation\n        );\n\n        const isAnimationEnabled = getAnimationEnabled(animation);\n\n        const transitionPreset =\n          animation !== 'default'\n            ? NAMED_TRANSITIONS_PRESETS[animation]\n            : isModal || optionsForTransitionConfig.presentation === 'modal'\n              ? ModalTransition\n              : optionsForTransitionConfig.presentation === 'transparentModal'\n                ? ModalFadeTransition\n                : DefaultTransition;\n\n        const {\n          gestureEnabled = Platform.OS === 'ios' && isAnimationEnabled,\n          gestureDirection = transitionPreset.gestureDirection,\n          transitionSpec = transitionPreset.transitionSpec,\n          cardStyleInterpolator = isAnimationEnabled\n            ? transitionPreset.cardStyleInterpolator\n            : forNoAnimationCard,\n          headerStyleInterpolator = transitionPreset.headerStyleInterpolator,\n          cardOverlayEnabled = (Platform.OS !== 'ios' &&\n            optionsForTransitionConfig.presentation !== 'transparentModal') ||\n            getIsModalPresentation(cardStyleInterpolator),\n        } = optionsForTransitionConfig;\n\n        const headerMode: StackHeaderMode =\n          descriptor.options.headerMode ??\n          (!(\n            optionsForTransitionConfig.presentation === 'modal' ||\n            optionsForTransitionConfig.presentation === 'transparentModal' ||\n            nextOptions?.presentation === 'modal' ||\n            nextOptions?.presentation === 'transparentModal' ||\n            getIsModalPresentation(cardStyleInterpolator)\n          ) &&\n          Platform.OS === 'ios' &&\n          descriptor.options.header === undefined\n            ? 'float'\n            : 'screen');\n\n        const isRTL = props.direction === 'rtl';\n\n        const scene = {\n          route,\n          descriptor: {\n            ...descriptor,\n            options: {\n              ...descriptor.options,\n              animation,\n              cardOverlayEnabled,\n              cardStyleInterpolator,\n              gestureDirection,\n              gestureEnabled,\n              headerStyleInterpolator,\n              transitionSpec,\n              headerMode,\n            },\n          },\n          progress: {\n            current: getProgressFromGesture(\n              currentGesture,\n              state.layout,\n              descriptor.options,\n              isRTL\n            ),\n            next:\n              nextGesture && nextOptions?.presentation !== 'transparentModal'\n                ? getProgressFromGesture(\n                    nextGesture,\n                    state.layout,\n                    nextOptions,\n                    isRTL\n                  )\n                : undefined,\n            previous: previousGesture\n              ? getProgressFromGesture(\n                  previousGesture,\n                  state.layout,\n                  previousOptions,\n                  isRTL\n                )\n              : undefined,\n          },\n          __memo: [\n            state.layout,\n            descriptor,\n            nextOptions,\n            previousOptions,\n            currentGesture,\n            nextGesture,\n            previousGesture,\n          ],\n        };\n\n        if (\n          oldScene &&\n          scene.__memo.every((it, i) => {\n            // @ts-expect-error: we haven't added __memo to the annotation to prevent usage elsewhere\n            return oldScene.__memo[i] === it;\n          })\n        ) {\n          return oldScene;\n        }\n\n        return scene;\n      }\n    );\n\n    return {\n      routes: props.routes,\n      scenes,\n      gestures,\n      descriptors: props.descriptors,\n      headerHeights: getHeaderHeights(\n        scenes,\n        props.insets,\n        props.isParentHeaderShown,\n        props.isParentModal,\n        state.layout,\n        state.headerHeights\n      ),\n    };\n  }\n\n  constructor(props: Props) {\n    super(props);\n\n    this.state = {\n      routes: [],\n      scenes: [],\n      gestures: {},\n      layout: SafeAreaProviderCompat.initialMetrics.frame,\n      descriptors: this.props.descriptors,\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      headerHeights: {},\n    };\n  }\n\n  private handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    const layout = { width, height };\n\n    this.setState((state, props) => {\n      if (height === state.layout.height && width === state.layout.width) {\n        return null;\n      }\n\n      return {\n        layout,\n        headerHeights: getHeaderHeights(\n          state.scenes,\n          props.insets,\n          props.isParentHeaderShown,\n          props.isParentModal,\n          layout,\n          state.headerHeights\n        ),\n      };\n    });\n  };\n\n  private handleHeaderLayout = ({\n    route,\n    height,\n  }: {\n    route: Route<string>;\n    height: number;\n  }) => {\n    this.setState(({ headerHeights }) => {\n      const previousHeight = headerHeights[route.key];\n\n      if (previousHeight === height) {\n        return null;\n      }\n\n      return {\n        headerHeights: {\n          ...headerHeights,\n          [route.key]: height,\n        },\n      };\n    });\n  };\n\n  private getFocusedRoute = () => {\n    const { state } = this.props;\n\n    return state.routes[state.index];\n  };\n\n  private getPreviousScene = ({ route }: { route: Route<string> }) => {\n    const { getPreviousRoute } = this.props;\n    const { scenes } = this.state;\n\n    const previousRoute = getPreviousRoute({ route });\n\n    if (previousRoute) {\n      const previousScene = scenes.find(\n        (scene) => scene.descriptor.route.key === previousRoute.key\n      );\n\n      return previousScene;\n    }\n\n    return undefined;\n  };\n\n  render() {\n    const {\n      insets,\n      state,\n      routes,\n      openingRouteKeys,\n      closingRouteKeys,\n      onOpenRoute,\n      onCloseRoute,\n      renderHeader,\n      isParentHeaderShown,\n      isParentModal,\n      onTransitionStart,\n      onTransitionEnd,\n      onGestureStart,\n      onGestureEnd,\n      onGestureCancel,\n      detachInactiveScreens = Platform.OS === 'web' ||\n        Platform.OS === 'android' ||\n        Platform.OS === 'ios',\n    } = this.props;\n\n    const { scenes, layout, gestures, headerHeights } = this.state;\n\n    const focusedRoute = state.routes[state.index];\n    const focusedHeaderHeight = headerHeights[focusedRoute.key];\n\n    const isFloatHeaderAbsolute = this.state.scenes.slice(-2).some((scene) => {\n      const options = scene.descriptor.options ?? {};\n      const { headerMode, headerTransparent, headerShown = true } = options;\n\n      if (\n        headerTransparent ||\n        headerShown === false ||\n        headerMode === 'screen'\n      ) {\n        return true;\n      }\n\n      return false;\n    });\n\n    let activeScreensLimit = 1;\n\n    for (let i = scenes.length - 1; i >= 0; i--) {\n      const { options } = scenes[i].descriptor;\n      const {\n        // By default, we don't want to detach the previous screen of the active one for modals\n        detachPreviousScreen = options.presentation === 'transparentModal'\n          ? false\n          : getIsModalPresentation(options.cardStyleInterpolator)\n            ? i !==\n              findLastIndex(scenes, (scene) => {\n                const { cardStyleInterpolator } = scene.descriptor.options;\n\n                return (\n                  cardStyleInterpolator === forModalPresentationIOS ||\n                  cardStyleInterpolator?.name === 'forModalPresentationIOS'\n                );\n              })\n            : true,\n      } = options;\n\n      if (detachPreviousScreen === false) {\n        activeScreensLimit++;\n      } else {\n        // Check at least last 2 screens before stopping\n        // This will make sure that screen isn't detached when another screen is animating on top of the transparent one\n        // For example, (Opaque -> Transparent -> Opaque)\n        if (i <= scenes.length - 2) {\n          break;\n        }\n      }\n    }\n\n    const floatingHeader = (\n      <React.Fragment key=\"header\">\n        {renderHeader({\n          mode: 'float',\n          layout,\n          scenes,\n          getPreviousScene: this.getPreviousScene,\n          getFocusedRoute: this.getFocusedRoute,\n          onContentHeightChange: this.handleHeaderLayout,\n          style: [\n            styles.floating,\n            isFloatHeaderAbsolute && [\n              // Without this, the header buttons won't be touchable on Android when headerTransparent: true\n              { height: focusedHeaderHeight },\n              styles.absolute,\n            ],\n          ],\n        })}\n      </React.Fragment>\n    );\n\n    return (\n      <View style={styles.container}>\n        {isFloatHeaderAbsolute ? null : floatingHeader}\n        <MaybeScreenContainer\n          enabled={detachInactiveScreens}\n          style={styles.container}\n          onLayout={this.handleLayout}\n        >\n          {[...routes, ...state.preloadedRoutes].map((route, index) => {\n            const focused = focusedRoute.key === route.key;\n            const gesture = gestures[route.key];\n            const scene = scenes[index];\n            // It is possible that for a short period the route appears in both arrays.\n            // Particularly, if the screen is removed with `retain`, then it needs a moment to execute the animation.\n            // However, due to the router action, it immediately populates the `preloadedRoutes` array.\n            // Practically, the logic below takes care that it is rendered only once.\n            const isPreloaded =\n              state.preloadedRoutes.includes(route) && !routes.includes(route);\n            if (\n              state.preloadedRoutes.includes(route) &&\n              routes.includes(route) &&\n              index >= routes.length\n            ) {\n              return null;\n            }\n\n            // For the screens that shouldn't be active, the value is 0\n            // For those that should be active, but are not the top screen, the value is 1\n            // For those on top of the stack and with interaction enabled, the value is 2\n            // For the old implementation, it stays the same it was\n            let isScreenActive:\n              | Animated.AnimatedInterpolation<0 | 1 | 2>\n              | 0\n              | 1\n              | 2 = 1;\n\n            if (index < routes.length - activeScreensLimit - 1 || isPreloaded) {\n              // screen should be inactive because it is too deep in the stack\n              isScreenActive = STATE_INACTIVE;\n            } else {\n              const sceneForActivity = scenes[routes.length - 1];\n              const outputValue =\n                index === routes.length - 1\n                  ? STATE_ON_TOP // the screen is on top after the transition\n                  : index >= routes.length - activeScreensLimit\n                    ? STATE_TRANSITIONING_OR_BELOW_TOP // the screen should stay active after the transition, it is not on top but is in activeLimit\n                    : STATE_INACTIVE; // the screen should be active only during the transition, it is at the edge of activeLimit\n              isScreenActive = sceneForActivity\n                ? sceneForActivity.progress.current.interpolate({\n                    inputRange: [0, 1 - EPSILON, 1],\n                    outputRange: [1, 1, outputValue],\n                    extrapolate: 'clamp',\n                  })\n                : STATE_TRANSITIONING_OR_BELOW_TOP;\n            }\n\n            const {\n              headerShown = true,\n              headerTransparent,\n              freezeOnBlur,\n              autoHideHomeIndicator,\n            } = scene.descriptor.options;\n\n            const safeAreaInsetTop = insets.top;\n            const safeAreaInsetRight = insets.right;\n            const safeAreaInsetBottom = insets.bottom;\n            const safeAreaInsetLeft = insets.left;\n\n            const headerHeight =\n              headerShown !== false ? headerHeights[route.key] : 0;\n\n            // Start from current card and count backwards the number of cards with same interpolation\n            const interpolationIndex = getInterpolationIndex(scenes, index);\n            const isModal = getIsModal(\n              scene,\n              interpolationIndex,\n              isParentModal\n            );\n\n            const isNextScreenTransparent =\n              scenes[index + 1]?.descriptor.options.presentation ===\n              'transparentModal';\n\n            const detachCurrentScreen =\n              scenes[index + 1]?.descriptor.options.detachPreviousScreen !==\n              false;\n\n            return (\n              <MaybeScreen\n                key={route.key}\n                style={[StyleSheet.absoluteFill]}\n                enabled={detachInactiveScreens}\n                active={isScreenActive}\n                freezeOnBlur={freezeOnBlur}\n                shouldFreeze={isScreenActive === STATE_INACTIVE && !isPreloaded}\n                homeIndicatorHidden={autoHideHomeIndicator}\n                pointerEvents=\"box-none\"\n              >\n                <CardContainer\n                  index={index}\n                  interpolationIndex={interpolationIndex}\n                  modal={isModal}\n                  active={index === routes.length - 1}\n                  focused={focused}\n                  opening={openingRouteKeys.includes(route.key)}\n                  closing={closingRouteKeys.includes(route.key)}\n                  layout={layout}\n                  gesture={gesture}\n                  scene={scene}\n                  safeAreaInsetTop={safeAreaInsetTop}\n                  safeAreaInsetRight={safeAreaInsetRight}\n                  safeAreaInsetBottom={safeAreaInsetBottom}\n                  safeAreaInsetLeft={safeAreaInsetLeft}\n                  onGestureStart={onGestureStart}\n                  onGestureCancel={onGestureCancel}\n                  onGestureEnd={onGestureEnd}\n                  headerHeight={headerHeight}\n                  isParentHeaderShown={isParentHeaderShown}\n                  onHeaderHeightChange={this.handleHeaderLayout}\n                  getPreviousScene={this.getPreviousScene}\n                  getFocusedRoute={this.getFocusedRoute}\n                  hasAbsoluteFloatHeader={\n                    isFloatHeaderAbsolute && !headerTransparent\n                  }\n                  renderHeader={renderHeader}\n                  onOpenRoute={onOpenRoute}\n                  onCloseRoute={onCloseRoute}\n                  onTransitionStart={onTransitionStart}\n                  onTransitionEnd={onTransitionEnd}\n                  isNextScreenTransparent={isNextScreenTransparent}\n                  detachCurrentScreen={detachCurrentScreen}\n                  preloaded={isPreloaded}\n                />\n              </MaybeScreen>\n            );\n          })}\n        </MaybeScreenContainer>\n        {isFloatHeaderAbsolute ? floatingHeader : null}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  absolute: {\n    position: 'absolute',\n    top: 0,\n    start: 0,\n    end: 0,\n  },\n  floating: {\n    zIndex: 1,\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}